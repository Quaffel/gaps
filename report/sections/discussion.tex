\chapter{Discussions}
\section{Path length analysis}
In figure \ref{fig:overall_performances} we can see that the method yielding to the shortest path length is, as expected, A*. This is due to the fact that A$^*$ is designed to find the shortest path to the solution. MCTS provides the longest path length which is likely due to the stochastic nature of the algorithm. This can lead to suboptimal moves. It also does not naturally deal with loops/recurring states in the path unlike the two other methods. Greedy BFS is in between the two other method. This is because it does not aim to find the shortest path but rather to reach a leaf node as quickly as possible. If the heuristic is well designed, it should generally yield paths of descent length.

\section{Time Complexity Analysis}

The most time-consuming algorithm for solving the Gaps game is MCTS (Monte Carlo Tree Search), as it requires numerous iterations to find a good solution. In contrast, the Greedy BFS algorithm is the fastest because it simply jumps from one node to another by selecting the best move. It returns as soon as it reaches a leaf node, regardless of whether it is a solution. A$^*$ is in between, being slower than Greedy BFS but faster than MCTS.

When examining the timeout rates of these methods, a different trend emerges. A timeout occurs when a solution is not found, and the algorithm continues running, consuming significant resources while descending through the action tree. A$^*$ is the most prone to reaching a timeout because it balances exploration between depth and breadth, which slows its descent, delaying convergence to a leaf solution. On the other hand, while MCTS may take the longest to run, it is the least likely to run into a timeout. This is due to the bounded nature of MCTS exploration, controlled by the iteration step and maximum depth, allowing us to carefully control the maximum time it takes for MCTS to provide an answer.

\section{Success Rate Analysis}
Interestingly, the algorithm with the highest success rate is the simplest one: the Greedy BFS algorithm. This is likely because, unlike A$^*$, Greedy BFS does not aim to find the shortest path to the solution; it follows the best path at each step. MCTS is close behind in success rate, and its performance can be further improved by increasing the number of iterations. A$^*$ has the lowest success rate, primarily because it spends more time descending the tree to find the shortest path, often reaching a timeout before finding a solution. This is demonstrated in the final plot of Figure \ref{fig:overall_performances}.

Having a solution that takes a long time to find is not practical. Therefore, we do not consider extending the timeout for further experiments.

\section{A*}
The A$^*$ algorithm is also effective for solving the Gaps game because it narrows down the search efficiently by focusing on promising paths. However, if the goal is not to find a short path to the solution, this makes A$^*$ the least promising method for solving this game, as it is the slowest (reaches the timeout more often) and has the lowest success rate.

\section{Greedy BFS}
The Greedy BFS algorithm is the fastest and most efficient algorithm to solve the Gaps game. It is well-suited for this game because it does not aim to find the shortest path to the solution, but rather to reach a leaf node as quickly as possible. This is why it has the highest success rate. However, it does not guarantee a short path to the solution.

This shows that having a good way of counting the number of misplaced cards can already provide a good heuristic for finding a solution to the Gaps game. As mentioned in the section \ref{ssec:wellplaced}, finding a good way of counting the number of well-placed is not trivial. We believe that improving this function will increase the quality of the solutions.

\section{MCTS}
MCTS is well suited for the Gaps game because it allows for the exploration of a large state space in a depth-focused manner. Its backpropagation process enables the algorithm to efficiently and progressively converge towards a solution. However, this comes at the cost of high computational resources due to the significant number of iterations required, resulting in longer times to find a solution.

Better results can potentially be achieved by fine-tuning the number of iterations, the exploration constant $W_c$, and the weight constant $W_S$ in the UCB formula. Additionally, improving the selection and expansion policies can further enhance the performance of MCTS in solving the Gaps game.


